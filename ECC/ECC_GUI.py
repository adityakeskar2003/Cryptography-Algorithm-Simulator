import streamlit as st
from ECC import ECC_Algorithm
from display import display_cryptographic_result


def GUI():
    p = 2 ** 256 - 2 ** 224 + 2 ** 192 + 2 ** 96 - 1
    a = -3
    b = int('5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b', 16)
    Gx = int('6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296', 16)
    Gy = int('4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5', 16)
    n = int('ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551', 16)
    st.header("Elliptic Curve Cryptography (ECC) Algorithm")
    st.write(
        "Elliptic Curve Cryptography (ECC) is a type of public-key cryptography that uses the mathematics of elliptic curves to provide security. ECC is known for its high level of security with shorter key lengths compared to other cryptosystems like RSA.")
    st.write(" ")
    st.subheader("Mathematical Foundation")
    st.write("1. Elliptic Curves:")
    st.write("An elliptic curve is defined by an equation of the form ")
    st.write("y^(2) = x^(3) + ax + b")
    st.write(
        "where a and b are constants that satisfy the condition 4a^(3) + 27b^(2) != 0 to ensure no singular points")
    st.write("")
    st.write("2. Group Operations:")
    st.write(
        "a. Point Addition: if P and Q are two points on the elliptic curve, their sum R = P + Q is also a point on the curve")
    st.write("b. Point Doubling: if P is a point on the curve, 2P is the sum of P with itself")
    st.write(
        "c. Scalar Multiplication: Multiplying a point P by an integer k (denoted by kP) involves repeated point addition")
    st.write("")
    st.subheader("Key Generation")
    st.write(f"We use parameters of Eclipse curve P-256")
    st.write("Prime P: This defines the finite field Fp over the elliptical curve is defined ")
    display_cryptographic_result(p)
    st.write("Coefficient A and B: These specifies the values of elliptical Curves:")
    st.write("A:")
    display_cryptographic_result(a)
    st.write("B:")
    display_cryptographic_result(b)
    st.write(
        "Base Point G: This is a fixed point on the elliptic curve that is used as the generator for scalar multiplication")
    st.write("Gx")
    display_cryptographic_result(Gx)
    st.write("Gy")
    display_cryptographic_result(Gy)
    st.write(
        "Order N: This is the number of points on the elliptic curve, including the point at infinity, that forms a cyclic subgroup generated by the base point G.  It is a prime number and defines the number of possible keys.")
    display_cryptographic_result(n)
    st.subheader("Key Generation")
    if st.button('Generate ECC Keys'):
        st.session_state.private_key, st.session_state.public_key = ECC_Algorithm.generate_keys()

    if 'public_key' in st.session_state and 'private_key' in st.session_state:
        st.write("Important values required for Key Generation")
        st.write("Step 1: We randomly select integer d chosen from interval [1,n-1], where n is order of base point G")
        st.write("Generated Private Key d:")
        display_cryptographic_result(st.session_state.private_key)
        st.write("Step 2: We compute point Q = dG where G is base point of curve")
        st.write("Generated Public Key Q:")
        display_cryptographic_result(st.session_state.public_key)

        st.subheader("Encryption")
        st.write("")
        message = st.text_input("Enter the plain text:", key="plain_text_input")
        if message:
            st.session_state.message = message

        if st.button("Encrypt"):
            st.session_state.k, st.session_state.C1, st.session_state.C2 = ECC_Algorithm.encrypt(
                 st.session_state.message,st.session_state.public_key
            )

        if 'k' in st.session_state and 'C1' in st.session_state and 'C2' in st.session_state:
            st.write("We choose a random integer k from [1,n-1]:")
            display_cryptographic_result(st.session_state.k)
            st.write("We compute C1 and C2")
            st.write("C1 = kG")
            display_cryptographic_result(st.session_state.C1)
            st.write("C2 = Pm + kQ")
            display_cryptographic_result(st.session_state.C2)

            st.subheader("Decryption")
            if st.button("Decrypt"):
                st.session_state.S, decrypted_plaintext = ECC_Algorithm.decrypt(
                    st.session_state.C1, st.session_state.C2,
                    st.session_state.private_key
                )
                st.session_state.decrypted_plaintext = decrypted_plaintext
                st.write("The receiver, who knows the private key d compute:")
                st.write("We compute shared secret S = dC1, Since C1 = kG, S = d(kG) = dQ")
                display_cryptographic_result(st.session_state.S)
                st.write("Decrypted Hash")
                display_cryptographic_result(st.session_state.decrypted_plaintext)
                st.write("Decrypted Plaintext: Pm = C2 - S")
                display_cryptographic_result(st.session_state.message)




def GUI_Signing():
    p = 2 ** 256 - 2 ** 224 + 2 ** 192 + 2 ** 96 - 1
    a = -3
    b = int('5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b', 16)
    Gx = int('6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296', 16)
    Gy = int('4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5', 16)
    n = int('ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551', 16)
    st.header("Elliptic Curve Cryptography (ECC) Algorithm")
    st.write(
        "Elliptic Curve Cryptography (ECC) is a type of public-key cryptography that uses the mathematics of elliptic curves to provide security. ECC is known for its high level of security with shorter key lengths compared to other cryptosystems like RSA.")
    st.write(" ")
    st.subheader("Mathematical Foundation")
    st.write("1. Elliptic Curves:")
    st.write("An elliptic curve is defined by an equation of the form ")
    st.write("y^(2) = x^(3) + ax + b")
    st.write(
        "where a and b are constants that satisfy the condition 4a^(3) + 27b^(2) != 0 to ensure no singular points")
    st.write("")
    st.write("2. Group Operations:")
    st.write(
        "a. Point Addition: if P and Q are two points on the elliptic curve, their sum R = P + Q is also a point on the curve")
    st.write("b. Point Doubling: if P is a point on the curve, 2P is the sum of P with itself")
    st.write(
        "c. Scalar Multiplication: Multiplying a point P by an integer k (denoted by kP) involves repeated point addition")
    st.write("")
    st.subheader("Key Generation")
    st.write(f"We use parameters of Eclipse curve secp256k1")
    st.write("Prime P: This defines the finite field Fp over the elliptical curve is defined ")
    display_cryptographic_result(p)
    st.write("Coefficient A and B: These specifies the values of elliptical Curves:")
    st.write("A:")
    display_cryptographic_result(a)
    st.write("B:")
    display_cryptographic_result(b)
    st.write(
        "Base Point G: This is a fixed point on the elliptic curve that is used as the generator for scalar multiplication")
    st.write("Gx")
    display_cryptographic_result(Gx)
    st.write("Gy")
    display_cryptographic_result(Gy)
    st.write(
        "Order N: This is the number of points on the elliptic curve, including the point at infinity, that forms a cyclic subgroup generated by the base point G.  It is a prime number and defines the number of possible keys.")
    display_cryptographic_result(n)
    st.subheader("Key Generation")
    if st.button('Generate Keys'):
        st.session_state.private_key_sender, st.session_state.public_key_sender = ECC_Algorithm.generate_keys()
        st.session_state.private_key_receiver, st.session_state.public_key_receiver = ECC_Algorithm.generate_keys()

    if 'public_key_sender' in st.session_state and 'private_key_sender' in st.session_state and 'public_key_receiver' in st.session_state and 'private_key_receiver' in st.session_state:
        st.write("Important values required for Key Generation")
        st.write("Step 1: We randomly select integer d chosen from interval [1,n-1], where n is order of base point G")
        st.write("Generated Private Key d for Sender:")
        display_cryptographic_result(st.session_state.private_key_sender)
        st.write("Step 2: We compute point Q = dG where G is base point of curve")
        st.write("Generated Public Key Q: for Sender")
        display_cryptographic_result(st.session_state.public_key_sender)
        st.write(" ")
        st.write("Step 1: We randomly select integer d chosen from interval [1,n-1], where n is order of base point G")
        st.write("Generated Private Key d for Receiver:")
        display_cryptographic_result(st.session_state.private_key_receiver)
        st.write("Step 2: We compute point Q = dG where G is base point of curve")
        st.write("Generated Public Key Q for Receiver:")
        display_cryptographic_result(st.session_state.public_key_receiver)

        st.write(" ")
        st.write("Step 2. Sender encrypts message with Receiver's Public Key")
        message = st.text_input("Enter the plain text:", key="plain_text_input")
        if message:
            st.session_state.message = message

            if st.button("Encrypt with Receiver's Public Key"):
                st.session_state.k, st.session_state.C1, st.session_state.C2 = ECC_Algorithm.encrypt(
                    st.session_state.message, st.session_state.public_key_receiver,
                )

        if 'k' in st.session_state and 'C1' in st.session_state and 'C2' in st.session_state:
            st.write("We choose a random integer k from [1,n-1]:")
            display_cryptographic_result(st.session_state.k)
            st.write("We compute C1 and C2")
            st.write("C1 = kG")
            display_cryptographic_result(st.session_state.C1)
            st.write("C2 = Pm + kQ")
            display_cryptographic_result(st.session_state.C2)
            if st.button("Sign with Sender's Private Key"):
                st.session_state.k, st.session_state.r, st.session_state.s = ECC_Algorithm.sign_message(
                    st.session_state.message, st.session_state.private_key_sender
                )

            if 'r' in st.session_state and 's' in st.session_state and 'k' in st.session_state:
                st.write("We randomly select an integer k:")
                display_cryptographic_result(st.session_state.k)
                st.write("r: r = (kG)")
                display_cryptographic_result(st.session_state.r)
                st.write("s: s = k_inv(H(M) + dr)")
                display_cryptographic_result(st.session_state.s)

                if st.button("Verify with Sender's Public Key"):
                    st.session_state.w, st.session_state.u1, st.session_state.u2,st.session_state.is_verified = ECC_Algorithm.verify_signature(
                       st.session_state.message,st.session_state.r,st.session_state.s, st.session_state.public_key_sender,
                    )

                if 'is_verified' in st.session_state and 'w' in st.session_state and 'u1' in st.session_state and 'u2' in st.session_state:
                    st.write("We compute u1 : u1 = H(M)s(-1)")
                    display_cryptographic_result(st.session_state.u1)
                    st.write("We compute u2 : u2 = rs^(-1) mod n")
                    display_cryptographic_result(st.session_state.u2)
                    st.write("Then we check whether (u1(G) + u2(Q)) = r mod n")
                    display_cryptographic_result(st.session_state.is_verified)

                    if st.session_state.is_verified:
                        if st.button("Decrypt with Receiver's Private Key"):
                            st.session_state.S, st.session_state.decrypted_plaintext = ECC_Algorithm.decrypt(
                                st.session_state.C1, st.session_state.C2, st.session_state.private_key_receiver
                            )

                        if 'decrypted_plaintext' in st.session_state and 'S' in st.session_state:
                            st.write("The receiver, who knows the private key d compute:")
                            st.write("We compute shared secret S = dC1, Since C1 = kG, S = d(kG) = dQ")
                            display_cryptographic_result(st.session_state.S)
                            st.write("Decrypted Hash")
                            display_cryptographic_result(st.session_state.decrypted_plaintext)
                            st.write("Decrypted Plaintext: Pm = C2 - S")
                            display_cryptographic_result(st.session_state.message)
